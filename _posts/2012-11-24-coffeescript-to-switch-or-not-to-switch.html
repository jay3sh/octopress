---
layout: post
title: "Coffeescript: To switch or not to switch"
date: 2012-11-24
comments: false
---

<div class='post'>
For a long time during the development of <a href="http://www.3dtin.com/">3DTin</a> I was toying with the idea of switching to Coffeescript (<i>"CS" henceforth</i>) from Javascript (<i>"JS" henceforth</i>). I was looking for a comprehensive guide about what are the pros and cons for such move. I didn't find any such document at the time. Now I have been using CS on-and-off for <a href="http://www.3dtin.com/" target="_blank">3DTin</a> in past 6 months. I have learnt a lot about the potential benefits and pitfalls of CS. This blog post is a collection of what I've learnt. Hopefully it will benefit those who are wondering whether to jump the boat. But note that, my experiences are not conclusive. I am still not sure that complete switch to CS is a good thing for every JS project.<br /><br />Let's get started...<br /><br /><b>Coffeescript is <i>not</i> a language</b><br /><br />A better characterization of CS is a set of preprocessor macros (think of C preprocessor). It's just that Coffeescript is such a complete set of macros that it can pass as a language. It's more like a shorthand for JS. Why is it important to think it like this? For two reasons:<br /><br />1. You cannot get away from learning (or better mastering) Javascript. One of CS's design goals is to stay as close to JS as possible and not implement language features that JS cannot natively support. That means even if you use CS everywhere in your project, you should have good understanding of JS.<br /><br />2. You can use CS alongside JS. Since CS is merely a shorthand for JS, some files in your project can be written in CS, while other are written in plain JS. That helps in adopting CS in already big Javascript codebase, like ours.<br /><br />If you call Coffeescript a language written on top of Javascript, many people right away assume it's bound to be slower than corresponding Javascript (which is never true). (Do C preprocessor macros inherently make the generated C code slower? Not unless they are defined so)<br /><br /><b>The iterations</b><br /><br />Iterating is something we do so many times. Therefore writing <span style="font-family: Courier New, Courier, monospace;">"for(int i=0, l=arr.length; i&lt;l; i++) { ... }"</span> every time is very painful, especially if you are used to Python's way of iteration <span style="font-family: Courier New, Courier, monospace;">"for obj in arr: ..."</span>.<br /><br />In pure JS you have to use the long form <span style="font-family: Courier New, Courier, monospace;">for</span> incantation. There is `<span style="font-family: Courier New, Courier, monospace;">forEach</span>` in modern JS implementations, but who knows in which browser it breaks in what way. Our solution for this problem is <a href="http://underscorejs.org/">underscore.js</a>'s <span style="font-family: Courier New, Courier, monospace;">_.each</span> function. It is everywhere in our code.<br /><br />Only recently however I realised, that liberal use of <span style="font-family: Courier New, Courier, monospace;">_.each</span> can lead to significant slow downs. If the loop count is very large compared to the time spent in the body of the loop, you will see clear improvement in speed by using old-fashing for loop instead of _.each. CS gives you a compact way of iterating over an array and it automatically converts it to the most efficient JS code for doing it.<br /><br />This iteration in CS<br /><script src="https://gist.github.com/4138237.js?file=2.coffee"></script> translates to this in JS<br /><br /><script src="https://gist.github.com/4138237.js?file=2.js"></script>Best of both the worlds. <br /><br /><b>Named arguments</b><br /><br />Naming the arguments is the best way to implicitly document the source code.<br /><br />Moreover, in an ever-evolving environment the function signatures keep changing very often. If you rely on positional arguments, every time you add a new argument to the function, you have to check all the places from where it's already being invoked and check that the new argument doesn't break them. In JS, most of the times such new arguments are optional for the logic of the function, i.e. they can be <span style="font-family: Courier New, Courier, monospace;">undefined</span>. Therefore they can normally added at the end of the argument list, so that the existing invocations won't need any change. For example, your current function signature is <span style="font-family: Courier New, Courier, monospace;">function foo(arg0, arg1)</span>. You decide to accept another optional argument <span style="font-family: Courier New, Courier, monospace;">newArg</span>. You can change definition of&nbsp;<span style="font-family: Courier New, Courier, monospace;">foo</span> to&nbsp;<span style="font-family: Courier New, Courier, monospace;">function foo(arg0, arg1, newArg)</span>. All the existing invocations of <span style="font-family: Courier New, Courier, monospace;">foo</span> won't have to be changed, provided the body of <span style="font-family: Courier New, Courier, monospace;">foo</span> handles newArg being <span style="font-family: Courier New, Courier, monospace;">undefined</span> properly. But what if it makes sense to add <span style="font-family: Courier New, Courier, monospace;">newArg</span> before <span style="font-family: Courier New, Courier, monospace;">arg0</span>?<br /><br />In such circumstances, it helps to have named arguments. JS doesn't support them.<br /><br />For that matter CS also doesn't support them seamlessly, but it's easy enough to do. You can also add a line of code to gracefully define default value for an argument.<br /><script src="https://gist.github.com/4138237.js?file=3.coffee"></script> <span style="font-size: x-small;">I learnt this trick from this <a href="http://stackoverflow.com/questions/5238398/default-function-parameter-ordering">Stackoverflow question</a>.</span><br /><br /><b>Built-in classes</b><br /><br />There are many ways to define Classes in JS, because they aren't natively supported. We use <a href="http://dean.edwards.name/weblog/2006/03/base/" target="_blank">Base.js</a> in 3DTin. With CS, classes are supported as part of language definition. You can define your classes in a more familiar OO syntax without worrying about all the black-magic with prototypes.<br /><br /><script src="https://gist.github.com/4138237.js?file=4.coffee"></script> <br /><b>Avoids variable leaking</b><br /><br />In JS it's very easy to forget to add <span style="font-family: Courier New, Courier, monospace;">var</span> before a variable, resulting in that variable getting defined in global namespace. Do not think that creating scopes with <span style="font-family: Courier New, Courier, monospace;">(function() { ... })()</span> blocks is going to help. It helps only if you define the variable with <span style="font-family: Courier New, Courier, monospace;">var</span>, then it won't be visible outside that scope. But if you forget to add <span style="font-family: Courier New, Courier, monospace;">var</span>, it will leak and will get defined as member of the <span style="font-family: Courier New, Courier, monospace;">window</span> object. Here's a proof.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-ir9Fk1a2H7s/ULBMgdoMapI/AAAAAAAAEJk/CS4L-KHKMx0/s1600/Screen+Shot+2012-11-24+at+9.55.31+AM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="114" src="http://4.bp.blogspot.com/-ir9Fk1a2H7s/ULBMgdoMapI/AAAAAAAAEJk/CS4L-KHKMx0/s320/Screen+Shot+2012-11-24+at+9.55.31+AM.png" width="320" /></a></div>In CS you don't have to worry about explicitly declaring any variables. The CS compiler automatically generates the necessary <span style="font-family: Courier New, Courier, monospace;">var</span> declarations for all the variables you use. IMO this is one of the biggest advantages of CS.<br /><br /><b><i>this.</i> becomes <i>@</i></b><br /><br />In object oriented JS code, you are always going to access members of the class from inside it using <span style="font-family: Courier New, Courier, monospace;">this.</span> prefix. If there was a more compact way to do this, it could save a lot of keystrokes and source code real-estate. CS designers realized that and have provided a shorthand for this usage.<br /><br /><b>The Fat arrow</b><br /><br />There are lots of callback functions in typical JS code. Classes are also functions in JS. That leads to a problem with the use of <span style="font-family: Courier New, Courier, monospace;">this</span> keyword sometimes. Inside the body of a function,&nbsp;<span style="font-family: Courier New, Courier, monospace;">this</span> refers to the context of that function. Inside the body of a function that is part of a prototype, this context is the instance of the object. Therefore if you have written <span style="font-family: Courier New, Courier, monospace;">this</span>, inside a callback function body, that is defined inside a prototype member function, which is it going to point to? It points to the callback function's context. But many times you assume it's referring to the instance of the object. This is a common mistake a &nbsp;developer makes while starting with JS. If you want to refer to the instance of the object from inside the callback function, then this is the solution for it.<br /><br /><br /><script src="https://gist.github.com/4138237.js?file=1.js"></script> <br />CS Fat arrow notation lets you write this in a more compact manner.<br /><br /><script src="https://gist.github.com/4138237.js?file=1.coffee"></script> The use of fat arrow <span style="font-family: Courier New, Courier, monospace;">=&gt;</span>&nbsp;automatically tells CS compiler to define a reference to outer context, so that the code inside the closure body can use simple @ notation and still resolve to the right context. We have such pattern all over the code. It's easy to imagine then how cleaner our CS code looks than the original implementation.<br /><div><br /></div><b><i>return</i> is not necessary</b><br /><br />CS automatically adds a return wherever it deems it necessary (and also unnecessary). This is a huge benefit while writing functional code.<br /><br />You can write<br /><script src="https://gist.github.com/4138237.js?file=5.coffee"></script> instead of<br /><script src="https://gist.github.com/4138237.js?file=5.js"></script> <br /><b><br /></b><b>String formatting</b><br /><br />Are you tired of writing<br /><script src="https://gist.github.com/4138237.js?file=6.js"></script> CS makes it easy for you.<br /><script src="https://gist.github.com/4138237.js?file=6.coffee"></script> <br /><b><br /></b><b>Parenthesis during function calls - can be skipped (almost)</b><br /><br />CS lets you skip Parenthesis during function invocations. This can be a good thing or a bad thing. It can make your code look more beautiful, but its overuse can make it confusing. Also the skipping rules are not consistent. Take a look.<br /><script src="https://gist.github.com/4138819.js?file=7.coffee"></script> <br /><b><br /></b><b>Braces and commas for dictionaries - can be skipped</b><br /><br />Similar to parenthesis, you don't have to use braces while defining dictionaries / maps / objects. CS will automatically infer their structure based on context or indentation. This contributes a lot towards cleaning up redundant tokens from your source. If you are going to put each name-value pair on new line, you can get rid of commas too.<br /><br /><script src="https://gist.github.com/4138819.js?file=8.coffee"></script> Translates to <br /><script src="https://gist.github.com/4138819.js?file=8.js"></script> <br /><b><br /></b><b>Spanning source lines</b><br /><br />Since CS infers a lot of things from indentation, when you try to break a long line of source into multiple lines, you can trigger compilation failures or at worse mis-interpretation.<br /><script src="https://gist.github.com/4138819.js?file=9.coffee"></script> <br /><br /><br /><b>In closing</b><br />In past 6 months I have used CS for all new source code and rewritten some JS code in CS if it made sense. I clearly saw certain benefits, but also some pitfalls. Not sure which path I will continue on. But I hope this post will help you make your own decisions.<br /><br />It's of enormous help to have a continuously running watch script that compiles coffeescript files as you save them. I've written such script that watches all coffee, jade and less.css files in a directory tree and compiles them as soon as they change. You can find it <a href="https://gist.github.com/3083080" target="_blank">here</a>.</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>tamat</div>
<div class='content'>
This comment has been removed by a blog administrator.</div>
</div>
<div class='comment'>
<div class='author'>tamat</div>
<div class='content'>
Although the &quot;private attribute&quot; trick has lots of performance drawbacks</div>
</div>
<div class='comment'>
<div class='author'>Jayesh</div>
<div class='content'>
Nihar, good post. But that trick of hiding a method inside the class definition is not something specific to Coffeescript. There is nothing to stop you from doing it in Javascript. <br /><br />The crux of that idea is to define a function inside a scope and not expose it though the prototype. Then call it from member functions of the class using &quot;call&quot; and passing the context explicitly, so that the body of the private function can access the object instance using &quot;this&quot;. This idea is not something coffeescript specific. The generated Javascript code is effectively similar to what you used to write in Javascript.</div>
</div>
<div class='comment'>
<div class='author'>Nihar Sawant</div>
<div class='content'>
Coffeescript also supports Encapsulation by allowing us to define private functions. Here is one blog post I wrote <a href="http://dewbot.posterous.com/private-function-in-javascript-coffeescript" rel="nofollow">Private Function in Coffeescript and Javascript</a></div>
</div>
</div>
