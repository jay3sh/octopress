---
layout: post
title: "Panacea of debugging"
date: 2005-12-29
comments: false
---

<div class='post'>
Debugging is an inevitable part of implementation process of any software. No one writes a software in one shot. After compiler has corrected the syntactic errors, debugging is the only way to fix the semantic errors. A bug-free software is an impractical thing no matter at what stage of development the software is.<br /><br />It goes without saying, that I have burnt my share of midnight oil in this activity. I however believe that there must be a highest stage in a programmer's life where he/she does not need to debug, because the whole system is an open book to him/her. He/She will know about every possible thing that can go right or wrong in the given system. In past couple of days I used 2-3 very useful tools on a solaris machine to debug a problem.<br /><br />As I mentioned earlier, if you want to know what is going wrong in a given process and why, then you have to have as much insight into the process as you can. If you are debugging a process that you yourself are developing or have access to its source code and have a build environment, then you can put printfs or build a debug version of the binary and run the process inside a debugger. Debugger gives you the window into the running process. But the limitation of a debugger is that you can use it only with the debug version of the binary. Not always you have access to the source code of third party libraries. Debugger can only see as deep as the application programmer can. Once the process dives into kernel space there is very less you can know what it going on.<br /><br />At such times, tools like 'truss' (strace on linux) come to help. In past couple of days I was amazed to see the analytic power one gets with several options of truss. Truss gives you running account of system calls, signals, machine faults happening in a given process as it is running. While debugging distributed applications one wants to see</div>
